### Golang执行流分析

.go 文件 -> `go build 编译` -> 可执行文件 `.exe` -> 运行 -> 结果
.go 文件 -> `go run` -> 结果

`go run` & `go build`

- 先编译生成了可执行文件, 可以在没有 go 开发环境的机器上, 仍可以运行
- 如果 `go run`, 如果要在另一个机器上, 也需要 go 开发环境
- 在编译时, 编译器会将程序运行依赖库文件包含在可执行文件中, 所以,可执行文件变大了很多

**编译和运行**

1. 有了 go 源文件, 通过编译器将其编译成机器可以识别的二进制码文件
2. `go run` 对源文件直接运行

**开发注意事项**

1. Go源文件以 .go 为扩展
2. Go应用程序的执行入口是 `main` 函数
3. Go语言严格区分大小写
4. Go方法由一条条语句构成, 不需分号
5. Go编译器是一行行进行编译, 一行就写一条语句
6. Go语言`定义的变量`或者`import的包`未使用到, 代码不能编译通过
7. `大括号{}` 成对出现, 不可缺少

### Go 转义字符

- `\t` 制表符, 实现对齐的功能
- `\n` 换行
- `\\` 一个 `\`
- `\"` 一个 `"`
- `\r` 回车,

```go
fmt.Println("姓名\t年龄\t地址\nyym")
```

### 注释

- 注释的语句不会被编译
- 推荐行注释 //
- 正确的缩进和空白
- 运算符两边都加一个空格

### 变量

变量相当于内存中一个数据存储空间的表示, 通过变量名可以访问到变量(值)

1. 指定变量类型, 声明后不赋值, 使用默认值 `var i int`
2. 类型推导 `var num = 10`
3. 省略var, `:= 左侧变量应该未声明` => `name := "yym"`
4. 可一次性声明多个变量 `name, age := "yym", 12`
5. 全局变量 => 在函数外声明变量
6. 变量在同一个作用域中不能同名
7. 变量 = 变量名 + 值 + 类型

### 数据类型

- 基本数据类型
    - 数值型
        - 整数类型(`int int8 int16`)
        - 浮点类型(`float32 float64`)
    - 字符型(使用 byte 来保存单个字母字符)
    - 布尔型(bool)
    - 字符串(string)
- 复杂数据类型
    - 指针 pointer
    - 数组
    - 结构体 struct
    - 管道 channel
    - 函数
    - 切片 slice
    - 接口 interface
    - map

1. 整数类型

- int 有符号 uint 无符号

| 类型    | 有无符号 |     | 占用存储空间              | 表数范围 |
|-------|:----:|-----|---------------------|------|
| int8  |  有   | 1字节 | -128 ~ 127          |
| int16 |  有   | 2字节 | -2 15次方 ~ 2 15次方 -1 |
| int32 |  有   | 4字节 | -2 31 ~ 2 31 - 1    |
| int64 |  有   | 8字节 | -2 63 ~ 2 63 -1     |

| 类型     | 有误符合 | 占有存储空间 | 表数范围       |
|--------|------|--------|------------|
| unit8  | 无    | 1字节    | 0-255      |
| unit16 | 无    | 2字节    | 0-2的16次方-1 |
| unit32 | 无    | 4字节    | 0-2的32次方-1 |
| unit64 | 无    | 8字节    | 0-2的64次方-1 |

<!-- TOC -->

    * [一个字节](8位, 第一位无符号,表示一个数, 全部取0 = 0, 全部取1 2的8次方-1)

<!-- TOC -->

| 类型   | 有无符号 | 占用存储空间             | 表数范围                               | 备注            |
|------|------|--------------------|------------------------------------|---------------|
| int  | 有    | 32位系统4个字节, 64位8个字节 | -2的31次方~2的31次方-1, -2的63次方到2的63次方-1 |               |
| uint | 有    | 32位系统4个字节, 64位8个字节 | 0~2的32次方-1, 0~2的63次方-1             |               |
| rune | 有    | 与int32一样           | -2的31次方~2的31次方-1                   | 表示一个 unicode码 |
| byte | 无    | 与uint8等价           | 0~255                              | 当存储字符时选用byte  |

- 整型的使用细节
    1. Golang整数类型分: 有符号和无符号, int uint 的大小和系统有关
    2. Golang整型默认声明为 int 型
    3. 查看数据类型 `fmt.Printf("%T", variable)`
    4. 查看变量字节大小 `unsafe.Sizeof(variable)`
    5. Goland整型变量使用中, 遵循尽量使用占用空间小的数据类型

2. 浮点型: 存放小数的
    - 尾数部分可能丢失, 造成精度损失
    - float64精度比float32准确, 要保存一个精度高得数, 使用float64
    - Golang浮点类型有固定的范围和字段长度, 不受操作系统影响
    - 浮点类型默认为 `float64`
    - 十进制数形式: `5.12 .512 必须有小数点`
    - 推荐使用 `float64`

| 类型         | 占用存储空间 | 表数范围                   |
|------------|--------|------------------------|
| 单精度float32 | 4字节    | -3.403e38 ~ 3.403e38   |
| 双精度float64 | 8字节    | -1.798e308 ~ 1.798e308 |

---

**字符类型**

Golang 中没有专门的字符类型, 如果需要存储单个字符(字母), 一般使用 `byte` 保存
Go的字符串由字节组成的

- 字符常量是用单引号 `''`括起来的单个字符, 例: `var c1 byte = 'a'`
- Go 中允许使用转义字符'\'来将其后的字符转变为特殊字符型常量, `var c4 byte = '\n'`
- Go语言的字符使用 UTF-8 编码
- 在 Go 中, 字符的本质是一个整数, 直接输出, 是该字符对应的`UTF-8`编码的码值
- 可以直接给某个变量赋一个数字, 然后格式化输出是 `%c`, 输出该字符的 unicode 字符
- 字符类型可以运算, 相当于一个整数
- 字符型存储到计算机, 需要将对应的码值找出来
- 字符和码值的对应关系是通过字符编码表决定的
    - 存储: 字符 -> 对应码值 -> 二进制 -> 存储
    - 读取: 二进制 -> 码值 -> 字符 -> 读取
- Go语言的编码统一成了 utf-8

**布尔类型 bool**

- 布尔类型也叫 bool 类型, 只允许取值 `true/false`
- bool类型占用1个字节
- 适用于逻辑运算, 一般用于流程控制

```go
var isHe bool = true
```

**字符串类型**

字符串就是一串固定长度的字符连接起来的字符序列. Go的字符串是由单个字节连接起来的, Go语言的字符串字节
使用 `utf-8`编码标识Unicode文本

```go
var address string = "北京欢迎你"
```

- 字符串一旦赋值, 不能修改
- 字符串两种表现形式
    - 双引号 ""
    - 反引号, 以字符串的原生形式输出, 包括换行和特殊字符, 可以实现防止攻击, 输出源代码
- 字符串拼接过长, + 号保留在上一行

**基本数据类型默认值**

| 数据类型 | 默认值   |
|------|-------|
| 整型   | 0     |
| 浮点型  | 0     |
| 字符串  | ""    |
| 布尔类型 | false |

### 基本数据相互转换

Golang数据类型`不能自动转换`

- 基本语法: 表达式 `T(v)` 值 v 转换为类型 T
  - T: 数据类型, 比如 `int32 int64 float32`
  - v: 就是需要转换的变量

```go
var i int = 100
// 把 i 类型转换为 float32
var n1 float32 = float32(i)
var n2 int8 = int8(i)
```

- Go数据类型转换可以从 表示范围小 -> 表示范围大, 也可以范围大 -> 范围小
- 被转换的是变量存储的数据(值), 变量本身的数据类型没有变化


**基本数据类型 -> string类型**

1. `fmt.Sprintf("%参数", 表达式)` -> `example/practice/baseToString`
2. 使用 `strconv` 包的函数

**string类型转换为基本类型**

1. 使用 `strconv` 包的函数
2. 确保 string类型能够转换成有效的数据


### 指针

1. 基本数据类型. 变量存的是值, 值类型
2. 获取变量地址, 用 `&` `var num int => &num`
3. 指针类型, 指针变量存的是一个地址, 这个地址指向的空间存的才是值 `var ptr *int = &num`
4. 获取指针类型所指向的值, 使用 `*`, `var ptr *int => *ptr 获取ptr指向的值`
5. 值类型, 都有对应的指针类型, 形式为 `*数据类型`, `int -> *int`
6. 值类型包括: 基本数据类型: int系列 float bool string 数组和结构体struct

### 值类型和引用类型

- 值类型: 基本数据类型 int float bool string 数组和结构体struct
  - 变量直接存储值, 内存通常在栈中分配
- 引用类型: 指针, slice切片, map, 管道, interface
  - 变量存储是地址, 地址对应的空间才是存储的值, 内存通常在堆上分配, 没有变量引用地址, 地址空间称为一个垃圾, 由GC回收

### 计算机进制

对于整数, 有四种表示方式

1. 二进制: 0 1 满2进1
2. 十进制: 0-9 满10进1
3. 八进制: 0-7 满8进1, 以数字 0 开头表示
4. 十六进制: 0-9及A-F, 满16进1, 以 `0x 0X开头`, A-F不区分大小写


**其它进制转十进制**

1. 二进制转10进制
   - 规则: 从最低位开始, 将每个位上的数提取出来, 乘以2的(位数-1)次方, 然后求和
   - 1011 => 十进制: 1*2的0次方 + 1*2的1次方+ 0*2的2次方 + 1* 2的3次方 = 11
2. 八进制转十进制
   - 规则: 从最低位开始, 每个微商的数提取出来, 乘以8的(位数-1)次方, 求和
   - 0123 => 十进制: 3*8的0次方+2*8的1次方+1*8的2次方+0 = 83
3. 十六进制转十进制
   - 规则: 从最低位, 每个位上的数提出来, 乘以16的(位数-1)次方, 求和
   - 0x34a => 十进制: 10*16的0次方+4*16的1次方+3*16的2次方 = 10+64+768=842

**十进制转其他进制**

1. 十进制转二进制
   - 数字不断除以2, 知道商为0为值, 然后将每步得到的余数倒过来, 就是对应的二进制
   - 56 => 二进制: 56%2=0 28%2=0 14%2=0 7%2=1 3%2=1 1 => 111000
2. 十进制转八进制
   - 数字不断除以8, 直到商为0为止,每步的余数倒过来, 对应的八进制, 前面补0
   - 156 => 八进制: 156%8=4 19%8=3 商2, => 0234
3. 十进制转十六进制
   - 数字不断除以16, 直到商为0, 每步余数倒过来, 对应的十六进制, 前面补 0x
   - 356 => 十六进制: 356%16=4 22%16=6 余1 => 0x164


**二进制转八进制**

- 将二进制数每三位一组(从低位开始组合), 转成对应的八进制即可
- 11010101 -> 八进制: 101 => 5 010 => 2 11 => 3 => 0325 三位一组转10进制拼接

**二进制转十六进制**

- 将二进制每四位一组, 转成对应十六进制即可
- 11010101 -> 0101 => 5 1101 => d => 0xd5

**八进制转二进制**

- 将八进制的每一位, 转成对应的一个3位二进制即可
- 0237 => 二进制 :2-> 10 3-> 011 7-> 111  => 10011111

**十六进制转二进制**

- 将十六进制的每一位, 转成对应的一个4位二进制即可
- 0x237 => 二进制: 2-> 10 2-> 0011 7-> 0111 => 1000110111

### 位运算

**原码 反码 补码**

- 用8位二进制表示一个数, +12的原码为`00001100` -12的原码为 `10001100`
- 对于单个数值（二进制的 0 和 1）而言，对其进行取反操作就是将 0 变为 1，1 变为 0
- 正数的反码和原码一样，负数的反码就是在原码的基础上符号位保持不变，其他位取反


对于有符号的而言

- 二进制的最高位是符号位: 0表示正数, 1表示负数
- 正数的原码 反码 补码都一样
- 负数的反码=它的原码符号位不变, 其它位取反(0->1 1->0)
- 负数的补码 = 它的反码+1
- 0的反码,补码都是1
- 在计算机运算, 都是以补码的方式来运算的

Golang有三个位运算分别是: `按位与& 按位或| 按位异或^`

- `按位与 &` 两位全为1, 结果为1, 否则为0
- `按位或 |` 两位有一个为1, 结果为1, 否则为0
- `按位异或 ^` 两位一个为0, 一个为1, 结果为1, 否则为0

```go
// 2的补码 0000 0010
// 3的补码 0000 0011
2&3    // 0000 0010 => 2

2|3    // 0000 0011 => 3

2^3    // 0000 0001 => 1
// -2的原码 1000 0010 -> 反码 1111 1101 -> 补码 1111 1110
// 2的补码 0000 0010
-2^2 // 1111 1100(补码) => 反码 1111 1011 => 原码 1000 0100 => -4
```

Golang 中有2个移位运算符 `>> << 右移和左移`

- 右移运算符 `>>`: 低位溢出, 符号位不变, 并用符号位补溢出的高位
- 左移运算符 `<<`: 符号位不变, 低位补0

```go
// 1的补码 0000 0001, 向右移动2位 => 0000 0000 => 0
1 >> 2
// 1的补码 0000 0001, 向左移动2位 => 0000 0100 => 4
1 << 2
```