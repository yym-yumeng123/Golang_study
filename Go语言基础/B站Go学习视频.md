### Golang执行流分析

.go 文件 -> `go build 编译` -> 可执行文件 `.exe` -> 运行 -> 结果
.go 文件 -> `go run` -> 结果

`go run` & `go build`

- 先编译生成了可执行文件, 可以在没有 go 开发环境的机器上, 仍可以运行
- 如果 `go run`, 如果要在另一个机器上, 也需要 go 开发环境
- 在编译时, 编译器会将程序运行依赖库文件包含在可执行文件中, 所以,可执行文件变大了很多

**编译和运行**

1. 有了 go 源文件, 通过编译器将其编译成机器可以识别的二进制码文件
2. `go run` 对源文件直接运行

**开发注意事项**

1. Go源文件以 .go 为扩展
2. Go应用程序的执行入口是 `main` 函数
3. Go语言严格区分大小写
4. Go方法由一条条语句构成, 不需分号
5. Go编译器是一行行进行编译, 一行就写一条语句
6. Go语言`定义的变量`或者`import的包`未使用到, 代码不能编译通过
7. `大括号{}` 成对出现, 不可缺少

### Go 转义字符

- `\t` 制表符, 实现对齐的功能
- `\n` 换行
- `\\` 一个 `\`
- `\"` 一个 `"`
- `\r` 回车,

```go
fmt.Println("姓名\t年龄\t地址\nyym")
```

### 注释

- 注释的语句不会被编译
- 推荐行注释 //
- 正确的缩进和空白
- 运算符两边都加一个空格

### 变量

变量相当于内存中一个数据存储空间的表示, 通过变量名可以访问到变量(值)

1. 指定变量类型, 声明后不赋值, 使用默认值 `var i int`
2. 类型推导 `var num = 10`
3. 省略var, `:= 左侧变量应该未声明` => `name := "yym"`
4. 可一次性声明多个变量 `name, age := "yym", 12`
5. 全局变量 => 在函数外声明变量
6. 变量在同一个作用域中不能同名
7. 变量 = 变量名 + 值 + 类型

### 数据类型

- 基本数据类型
    - 数值型
        - 整数类型(`int int8 int16`)
        - 浮点类型(`float32 float64`)
    - 字符型(使用 byte 来保存单个字母字符)
    - 布尔型(bool)
    - 字符串(string)
- 复杂数据类型
    - 指针 pointer
    - 数组
    - 结构体 struct
    - 管道 channel
    - 函数
    - 切片 slice
    - 接口 interface
    - map

1. 整数类型

- int 有符号 uint 无符号

| 类型    | 有无符号 |     | 占用存储空间              | 表数范围 |
|-------|:----:|-----|---------------------|------|
| int8  |  有   | 1字节 | -128 ~ 127          |
| int16 |  有   | 2字节 | -2 15次方 ~ 2 15次方 -1 |
| int32 |  有   | 4字节 | -2 31 ~ 2 31 - 1    |
| int64 |  有   | 8字节 | -2 63 ~ 2 63 -1     |

| 类型     | 有误符合 | 占有存储空间 | 表数范围       |
|--------|------|--------|------------|
| unit8  | 无    | 1字节    | 0-255      |
| unit16 | 无    | 2字节    | 0-2的16次方-1 |
| unit32 | 无    | 4字节    | 0-2的32次方-1 |
| unit64 | 无    | 8字节    | 0-2的64次方-1 |

<!-- TOC -->

    * [一个字节](8位, 第一位无符号,表示一个数, 全部取0 = 0, 全部取1 2的8次方-1)

<!-- TOC -->

| 类型   | 有无符号 | 占用存储空间             | 表数范围                               | 备注            |
|------|------|--------------------|------------------------------------|---------------|
| int  | 有    | 32位系统4个字节, 64位8个字节 | -2的31次方~2的31次方-1, -2的63次方到2的63次方-1 |               |
| uint | 有    | 32位系统4个字节, 64位8个字节 | 0~2的32次方-1, 0~2的63次方-1             |               |
| rune | 有    | 与int32一样           | -2的31次方~2的31次方-1                   | 表示一个 unicode码 |
| byte | 无    | 与uint8等价           | 0~255                              | 当存储字符时选用byte  |

- 整型的使用细节
    1. Golang整数类型分: 有符号和无符号, int uint 的大小和系统有关
    2. Golang整型默认声明为 int 型
    3. 查看数据类型 `fmt.Printf("%T", variable)`
    4. 查看变量字节大小 `unsafe.Sizeof(variable)`
    5. Goland整型变量使用中, 遵循尽量使用占用空间小的数据类型

2. 浮点型: 存放小数的
    - 尾数部分可能丢失, 造成精度损失
    - float64精度比float32准确, 要保存一个精度高得数, 使用float64
    - Golang浮点类型有固定的范围和字段长度, 不受操作系统影响
    - 浮点类型默认为 `float64`
    - 十进制数形式: `5.12 .512 必须有小数点`
    - 推荐使用 `float64`

| 类型         | 占用存储空间 | 表数范围                   |
|------------|--------|------------------------|
| 单精度float32 | 4字节    | -3.403e38 ~ 3.403e38   |
| 双精度float64 | 8字节    | -1.798e308 ~ 1.798e308 |

---

**字符类型**

Golang 中没有专门的字符类型, 如果需要存储单个字符(字母), 一般使用 `byte` 保存
Go的字符串由字节组成的

- 字符常量是用单引号 `''`括起来的单个字符, 例: `var c1 byte = 'a'`
- Go 中允许使用转义字符'\'来将其后的字符转变为特殊字符型常量, `var c4 byte = '\n'`
- Go语言的字符使用 UTF-8 编码
- 在 Go 中, 字符的本质是一个整数, 直接输出, 是该字符对应的`UTF-8`编码的码值
- 可以直接给某个变量赋一个数字, 然后格式化输出是 `%c`, 输出该字符的 unicode 字符
- 字符类型可以运算, 相当于一个整数
- 字符型存储到计算机, 需要将对应的码值找出来
- 字符和码值的对应关系是通过字符编码表决定的
    - 存储: 字符 -> 对应码值 -> 二进制 -> 存储
    - 读取: 二进制 -> 码值 -> 字符 -> 读取
- Go语言的编码统一成了 utf-8

**布尔类型 bool**

- 布尔类型也叫 bool 类型, 只允许取值 `true/false`
- bool类型占用1个字节
- 适用于逻辑运算, 一般用于流程控制

```go
var isHe bool = true
```

**字符串类型**

字符串就是一串固定长度的字符连接起来的字符序列. Go的字符串是由单个字节连接起来的, Go语言的字符串字节
使用 `utf-8`编码标识Unicode文本

```go
var address string = "北京欢迎你"
```

- 字符串一旦赋值, 不能修改
- 字符串两种表现形式
    - 双引号 ""
    - 反引号, 以字符串的原生形式输出, 包括换行和特殊字符, 可以实现防止攻击, 输出源代码
- 字符串拼接过长, + 号保留在上一行

**基本数据类型默认值**

| 数据类型 | 默认值   |
|------|-------|
| 整型   | 0     |
| 浮点型  | 0     |
| 字符串  | ""    |
| 布尔类型 | false |

### 基本数据相互转换

Golang数据类型`不能自动转换`

- 基本语法: 表达式 `T(v)` 值 v 转换为类型 T
  - T: 数据类型, 比如 `int32 int64 float32`
  - v: 就是需要转换的变量

```go
var i int = 100
// 把 i 类型转换为 float32
var n1 float32 = float32(i)
var n2 int8 = int8(i)
```

- Go数据类型转换可以从 表示范围小 -> 表示范围大, 也可以范围大 -> 范围小
- 被转换的是变量存储的数据(值), 变量本身的数据类型没有变化


**基本数据类型 -> string类型**

1. `fmt.Sprintf("%参数", 表达式)` -> `example/practice/baseToString`
2. 使用 `strconv` 包的函数

**string类型转换为基本类型**

1. 使用 `strconv` 包的函数
2. 确保 string类型能够转换成有效的数据


### 指针

1. 基本数据类型. 变量存的是值, 值类型
2. 获取变量地址, 用 `&` `var num int => &num`
3. 指针类型, 指针变量存的是一个地址, 这个地址指向的空间存的才是值 `var ptr *int = &num`
4. 获取指针类型所指向的值, 使用 `*`, `var ptr *int => *ptr 获取ptr指向的值`
5. 值类型, 都有对应的指针类型, 形式为 `*数据类型`, `int -> *int`
6. 值类型包括: 基本数据类型: int系列 float bool string 数组和结构体struct

### 值类型和引用类型

- 值类型: 基本数据类型 int float bool string 数组和结构体struct
  - 变量直接存储值, 内存通常在栈中分配
- 引用类型: 指针, slice切片, map, 管道, interface
  - 变量存储是地址, 地址对应的空间才是存储的值, 内存通常在堆上分配, 没有变量引用地址, 地址空间称为一个垃圾, 由GC回收
