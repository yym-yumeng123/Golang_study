### 流程控制

在程序中, 程序运行的流程控制决定程序是如何执行的

1. 顺序控制
2. 分支控制
3. 循环控制


#### 顺序控制

程序从上到下逐行执行, 中间没有跳转

#### 分支控制

分支控制让程序有选择的执行

1. 单分支
2. 双分支
3. 多分支
4. 嵌套分支
5. switch 分支
   - switch用于基于不同条件执行不同操作, 每个case 都是唯一的, 从上到下逐一测试
   - 先执行表达式, 得到值, 和case表达式比较, 相等, 匹配, 执行相应的语句
   - 如果都没有匹配, default执行
   - case 后的表达式可以有多个, 使用逗号相隔
   - case 后是一个表达式, 常量, 类型与 switch 表达式一致
   - switch 后也可以不带表达式, 类似 if else 使用
   - switch 穿透 fallthrough, 在case语句后增加 `fallthrough`, 会继续执行下一个 case

```go
// 单分支
if 条件表达式 {
	//执行代码块
}

var age int = 18
if age > 18 {
	fmt.Println("你需要对自己负责")
}

// 双分支
if 条件表达式 { // 条件表达式不带括号
	// 代码1
} else {
	// 代码2
}

// 多分支 只有一个入口
if 条件1 {
	// 代码1
} else if 条件2 {
	// 代码2
} else {
	// 代码n
}

// 嵌套分支
// 嵌套不宜过多, 最好不超过3层
if 条件1 {
	if 条件2 {
		
}else {
	
}
}
```


```go
// switch 分支
switch 表达式 {
case 表达式1:
	//语句块
case 表达式2: 
	//语句块
default:
	//语句块
}

switch {
case age > 10:
	...
	case age > 30:
			
		}
```


### 函数

为完成某一个功能的程序指令(语句)的集合称为函数

- 函数形参可以十多个, 返回值也可以多个
- 形参列表和返回值数据类型是值类型也可以是引用类型
- 函数命名遵循标识符规范, 首字母大写可以被本包文件和其他文件引用
- 函数中的变量是局部的, 函数外不生效
- `基本数据`类型和`数组`默认都是值传递, 即进行值拷贝, 在函数内修改, 不会影响原来的值
- 如果希望函数内的变量能修改函数外的变量, 可以传入变量地址`&`, 函数内以指针的方式操作变量
- Go函数不支持重载
- 在Go中, 函数也是数据类型, 可以赋给一个变量, 该变量就是一个函数类型的变量, 通过该变量可以对函数调用
- 函数既然是一种数据类型, 在Go中, 函数可以作为形参, 并且调用
- Go支持自定义数据类型
  - type 自定义数据类型名 数据类型 // 相当于别名
  - `type mySum func(int, int) int`
- 支持函数返回值命名
  - `func getSumANdSub(n1 int, n2 int) (sum int, sub int)`
- 使用 _ 标识符, 忽略返回值 `res, _ := cal(1,2)`
- 支持可变参数 `func sum(args... int) sum int` 只能放在形参列表最后


```go
// 形参: 表示函数的输入
func 函数名 (形参列表) (返回值列表) {
	执行语句
	return 返回值列表
}

函数名(实参)
```

函数调用机制

示例1: ![函数调用分析](../函数调用分析.png)


- 在调用一个函数时, 会给函数分配一个新的空间, 编译器会通过自身处理让这个空间和其它栈的空间区分开来
- 在每个函数对应的栈中, 数据空间时空间的, 不会混淆
- 当一个函数执行完毕后, 程序会销毁这个函数对应的空间


函数递归调用

![递归抵用分析](../递归栈内存.png)

一个函数在函数体内调用了自身, 称为递归调用

- 执行一个函数时, 就创建一个新的受保护的独立空间
- 函数的局部变量时独立的, 不会相互影响
- 递归必须有终止条件
- 当一个函数执行完毕, 或者遇到 return, 就会返回, 同时该函数也会被销毁

```go
func test1(n int) {
	if n > 2 {
		n--
		test1(n)
	}
	fmt.Println("n=", n)
}

test1(4)
```




























