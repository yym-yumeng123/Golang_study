### 流程控制

在程序中, 程序运行的流程控制决定程序是如何执行的

1. 顺序控制
2. 分支控制
3. 循环控制


#### 顺序控制

程序从上到下逐行执行, 中间没有跳转

#### 分支控制

分支控制让程序有选择的执行

1. 单分支
2. 双分支
3. 多分支
4. 嵌套分支
5. switch 分支
   - switch用于基于不同条件执行不同操作, 每个case 都是唯一的, 从上到下逐一测试
   - 先执行表达式, 得到值, 和case表达式比较, 相等, 匹配, 执行相应的语句
   - 如果都没有匹配, default执行
   - case 后的表达式可以有多个, 使用逗号相隔
   - case 后是一个表达式, 常量, 类型与 switch 表达式一致
   - switch 后也可以不带表达式, 类似 if else 使用
   - switch 穿透 fallthrough, 在case语句后增加 `fallthrough`, 会继续执行下一个 case

```go
// 单分支
if 条件表达式 {
	//执行代码块
}

var age int = 18
if age > 18 {
	fmt.Println("你需要对自己负责")
}

// 双分支
if 条件表达式 { // 条件表达式不带括号
	// 代码1
} else {
	// 代码2
}

// 多分支 只有一个入口
if 条件1 {
	// 代码1
} else if 条件2 {
	// 代码2
} else {
	// 代码n
}

// 嵌套分支
// 嵌套不宜过多, 最好不超过3层
if 条件1 {
	if 条件2 {
		
}else {
	
}
}
```


```go
// switch 分支
switch 表达式 {
case 表达式1:
	//语句块
case 表达式2: 
	//语句块
default:
	//语句块
}

switch {
case age > 10:
	...
	case age > 30:
			
		}
```


### 函数

为完成某一个功能的程序指令(语句)的集合称为函数

```go
// 形参: 表示函数的输入
func 函数名 (形参列表) (返回值列表) {
	执行语句
	return 返回值列表
}

函数名(实参)
```

函数调用机制

示例1: ![函数调用分析](../函数调用分析.png)


- 在调用一个函数时, 会给函数分配一个新的空间, 编译器会通过自身处理让这个空间和其它栈的空间区分开来
- 在每个函数对应的栈中, 数据空间时空间的, 不会混淆
- 当一个函数执行完毕后, 程序会销毁这个函数对应的空间


函数递归调用

![递归抵用分析](../递归栈内存.png)

一个函数在函数体内调用了自身, 称为递归调用

- 执行一个函数时, 就创建一个新的受保护的独立空间
- 函数的局部变量时独立的, 不会相互影响
- 递归必须有终止条件
- 当一个函数执行完毕, 或者遇到 return, 就会返回, 同时该函数也会被销毁

```go
func test1(n int) {
	if n > 2 {
		n--
		test1(n)
	}
	fmt.Println("n=", n)
}

test1(4)
```




























