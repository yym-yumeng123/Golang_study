## 排序和查找

### 排序


- 将一组数据, 依照指定的顺序进行排列
  - 内部排序: 将需要处理的所有数据都加载到内部存储器中进行排序
    - 交换式排序法
      - 冒泡排序法 bubble sort
      - 快速排序法 quick sort
    - 选择式排序法
    - 插入式排序法
  - 外部排序法: 数据量过大, 无法全部加载到内存中, 需要借助外部存储进行
    - 合并排序法
    - 直接合并排序

**冒泡排序法**

案例1: 五个无序: 24 69 80 57 13, 排成从小到大的有序数列, 思路

- 外层: n 个数据, n-1 轮比较
- 上面每一轮循环, 确定一个数的位置
- 每一轮的比较逐渐减少
- 当前面的一个数比后面的一个数大的时候, 就进行交换

第一轮排序 外层

1. 第一次比较: 24和69比较, 前面的数大, 则交换
2. 第二次比较: 69和80比较, 没变
3. 第三次比较: 80和57比较, 80>57 交换, [24, 69, 57, 80, 13]
4. 第四次: 80和13比较, 80>13  [24, 69, 57, 13, 80]

第二轮排序 外层,

1. 第一次比较: 24和69比较, 前面的数大, 则交换 [24, 69, 57, 13, 80]
2. 第二次比较: 69和57比较, [24, 57, 69, 13, 80]
3. 第三次比较: 69和13比较, 69>13 交换, [24, 57, 13, 69, 80]


第三轮排序 外层

1. 第一次比较: 24和57比
2. 第二次比较: 57和13比较, [24, 13, 57, 69, 80]

第四轮排序 外层

1. 第一次比较: 24和13比 [13, 24, 57, 69, 80]

```go
// BubbleSort 冒泡排序
func BubbleSort(arr *[]int) {
	temp := 0
	fmt.Println("排序前", *arr)
	for j := 1; j < len(*arr); j++ {
		for i := 0; i < len(*arr)-j; i++ {
			if (*arr)[i] > (*arr)[i+1] {
				//(*arr)[i+1] = (*arr)[i]
				temp = (*arr)[i]
				(*arr)[i] = (*arr)[i+1]
				(*arr)[i+1] = temp
			}
		}
	}
	fmt.Println("排序后", *arr)

}
```

### 查找

- 顺序查找
- 二分查找(数组是有序的) [1, 8, 10, 100, 123]
  - 从两头找中间, leftIndex, rightIndex
  - 先找到中间的下标 middle = (leftIndex + rightIndex) / 2, middle 的值和目标值进行比较
  - 如果arr[middle] > findVal, 向 leftIndex - (middle - 1) 范围找
  - 如果arr[middle] < findVal, 向 (middle + 1) - rightIndex 范围找
  - 如果 ==, 就找到了
  - 上面的逻辑会递归
  - 退出递归的条件: leftIndex > rightIndex


























