### 数据结构(算法)的介绍

程序 = 数据结构 + 算法

- 算法是程序的灵魂


### 稀疏数组 sparse array

如果一个多维数组中，存放了很多相同的元素，不同的元素很少，那就是一个稀疏数组

当一个数组中大部分元素为 0, 或者为同一个值的数组时, 可以使用稀疏数组来保存该数组

- 记录数组一共有几行几列
- 思想: 把具有不同值的元素的行列及值记录在一个小规模的数组中, 从而缩小程序的规模

```go
// 假如有下面一些值 (压缩)
0 0 0 22 0 0 15
0 11 0 0 0 17 0
0 0 0 -6 0 0 0 
0 0 0 0 0 39 0
91 0 0 0 0 0 0
0 0 28 0 0 0 0

// => 
6行 7列 值
row col val
0   3   22
0   6   15
...
5   2   28
```

应用实例

1. 使用稀疏数组, 来保留类似前面的二维数组, (棋盘 地图等)
2. 把稀疏数组存盘, 并且可以重新恢复原来的二维数组数

```go
// 数组转稀疏数组
type ValNode struct {
  row int // 列
  col int // 行
  val int // 值
}

func main() {
  // 1. 创建一个原始数组
  var chessMap [11][11]int
  chessMap[1][2] = 1 // 黑子
  chessMap[2][3] = 2 // 白字
  // 2. 原始数组
  for _, v := range chessMap {
    fmt.Println(v)
  }

  // 3. 转成稀疏数组
  // 遍历, 有一个元素的值不为 0, 创建一个 node 结构体,
  // 放入对应的切片
  var sparseArr []ValNode

  // 标准的稀疏数组含有一个表示记录原始二维数组的规模(行数, 列数, 默认值)
  firstValNode := ValNode{
    row: 11,
    col: 11,
    val: 0,
  }

  sparseArr = append(sparseArr, firstValNode)

  for i, v := range chessMap {
    for j, v2 := range v {
      if v2 != 0 {
        sparseArr = append(sparseArr, ValNode{
          row: i,
          col: j,
          val: v2,
        })
      }
    }
  }

  fmt.Println(sparseArr)
}

```

```go
	// 创建一个原始数组
	var arr [11][11]int
	// 4. 将稀疏数组 sparseArr 恢复
	for i, valNode := range sparseArr {
		if i != 0 {
			arr[valNode.row][valNode.col] = valNode.val
		}
	}

	for _, v := range arr {

		fmt.Println(v, "arr")
	}
```


### 队列

- 是一个有序列表, 可以用数组或是链表来实现
- 遵循陷入先出的原则

数组模拟队列

- 队列本身是有序列表,若使用数组的结构来存储队列的数据, 则队列数据的声明如下
  - `maxSize` 是该队列的最大容量
- 因为队列的输出, 输入分别从前后端来处理, 需要两个变量
  - `front` 前端的下标, 随着数据的输出而改变
  - `rear` 后端的下标, 随着数据的输入而改变