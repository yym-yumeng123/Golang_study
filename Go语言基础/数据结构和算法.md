### 数据结构(算法)的介绍

程序 = 数据结构 + 算法

- 算法是程序的灵魂


### 稀疏数组 sparse array

如果一个多维数组中，存放了很多相同的元素，不同的元素很少，那就是一个稀疏数组

当一个数组中大部分元素为 0, 或者为同一个值的数组时, 可以使用稀疏数组来保存该数组

- 记录数组一共有几行几列
- 思想: 把具有不同值的元素的行列及值记录在一个小规模的数组中, 从而缩小程序的规模

```go
// 假如有下面一些值 (压缩)
0 0 0 22 0 0 15
0 11 0 0 0 17 0
0 0 0 -6 0 0 0 
0 0 0 0 0 39 0
91 0 0 0 0 0 0
0 0 28 0 0 0 0

// => 
6行 7列 值
row col val
0   3   22
0   6   15
...
5   2   28
```

应用实例

1. 使用稀疏数组, 来保留类似前面的二维数组, (棋盘 地图等)
2. 把稀疏数组存盘, 并且可以重新恢复原来的二维数组数

```go
// 数组转稀疏数组
type ValNode struct {
  row int // 列
  col int // 行
  val int // 值
}

func main() {
  // 1. 创建一个原始数组
  var chessMap [11][11]int
  chessMap[1][2] = 1 // 黑子
  chessMap[2][3] = 2 // 白字
  // 2. 原始数组
  for _, v := range chessMap {
    fmt.Println(v)
  }

  // 3. 转成稀疏数组
  // 遍历, 有一个元素的值不为 0, 创建一个 node 结构体,
  // 放入对应的切片
  var sparseArr []ValNode

  // 标准的稀疏数组含有一个表示记录原始二维数组的规模(行数, 列数, 默认值)
  firstValNode := ValNode{
    row: 11,
    col: 11,
    val: 0,
  }

  sparseArr = append(sparseArr, firstValNode)

  for i, v := range chessMap {
    for j, v2 := range v {
      if v2 != 0 {
        sparseArr = append(sparseArr, ValNode{
          row: i,
          col: j,
          val: v2,
        })
      }
    }
  }

  fmt.Println(sparseArr)
}

```

```go
	// 创建一个原始数组
	var arr [11][11]int
	// 4. 将稀疏数组 sparseArr 恢复
	for i, valNode := range sparseArr {
		if i != 0 {
			arr[valNode.row][valNode.col] = valNode.val
		}
	}

	for _, v := range arr {

		fmt.Println(v, "arr")
	}
```


### 队列

- 是一个有序列表, 可以用数组或是链表来实现
- 遵循陷入先出的原则

数组模拟队列

- 队列本身是有序列表,若使用数组的结构来存储队列的数据, 则队列数据的声明如下
  - `maxSize` 是该队列的最大容量
- 因为队列的输出, 输入分别从前后端来处理, 需要两个变量
  - `front` 前端的下标, 随着数据的输出而改变
  - `rear` 后端的下标, 随着数据的输入而改变

```go
type Queue struct {
	front   int    // 指向队列的首位
	rear    int    // 指向队尾
	array   [5]int // 数组 => 模拟队列
	maxSize int
}

// AddQueue 数据添加到队列
func (q *Queue) AddQueue(val int) (err error) {
	// 先判断队列是否已满
	if q.rear == q.maxSize-1 {
		return errors.New("队列满了")
	}

	q.rear++ // rear 后移
	q.array[q.rear] = val
	return err
}

// ShowQueue 显示队列, 找到对首, 然后遍历到队尾
func (q *Queue) ShowQueue() {
	// front 不包含对首的元素
	for i := q.front + 1; i <= q.rear; i++ {
		fmt.Printf("arr[%d]=%d\n", i, q.array[i])
	}
}

func (q *Queue) GetQueue() (val int, err error) {
	// 先判断队列是否为空
	if q.front == q.rear {
		return -1, errors.New("队列空了")
	}

	q.front++ // front 往后移
	val = q.array[q.front]
	return val, err
}
```

数组模拟环形队列

1. 尾索引的下一个为头索引表示队列满, 即将 `队列容量空出一个作为约定`, 这个判断 `(tail + 1) % maxSize == head 满`
2. `tail == head` 空
3. 初始化时, tail = 0 head = 0
4. 统计队列有多少个元素: `(tail + maxSize - head) % maxSize`